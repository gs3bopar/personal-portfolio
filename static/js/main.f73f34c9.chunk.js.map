{"version":3,"sources":["gameState.js","materials/texturemap1024.png","materials/uluru-heightmap.png","App.js","shaders.js","index.js"],"names":["tankPositionState","atom","key","default","position","rotation","enemyPositionState","x","y","z","text","laserPositionState","scoreState","Model","props","tank","useRef","useRecoilState","setTankPosition","useFrame","mouse","fbx","useFBX","useEffect","console","log","traverse","child","isMesh","children","THREE","ref","receiveShadow","object","dispose","Terrain","heightMap","useTexture","uluru","encoding","wrapS","wrapT","anisotropy","textureMap","texturemap1024","minFilter","terrainRef","current","GAME_SPEED","Math","PI","args","fog","uniforms","bumpTexture","value","bumpScale","terrainTexture","vertexShader","fragmentShader","side","useGLTF","preload","Target","color","TargetText","textOptions","font","parse","Pokemon","size","height","emissive","roughness","metalness","wireframe","flatShading","vertexColors","Enemies","useRecoilValue","map","enemy","random","Lasers","lasers","laser","attach","id","LaserController","shipPosition","setLasers","onClick","velocity","visible","GameTimer","setAboutMeHit","setExperiencesHit","enemies","setLaserPositions","score","setScore","hitEnemies","filter","p1","p2","a","b","c","sqrt","distance","length","includes","Modal","show","showHideClassName","className","type","e","preventDefault","dosomething","App","useState","speed","setSpeed","aboutMeHit","style","background","camera","fov","near","far","dpr","max","window","devicePixelRatio","fallback","scale","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.f73f34c9.chunk.js","sourcesContent":["import { atom } from \"recoil\";\n\nexport const tankPositionState = atom({\n  key: \"tankPosition\", // unique ID (with respect to other atoms/selectors)\n  default: { position: {}, rotation: {} } // default value (aka initial value)\n});\n\nexport const enemyPositionState = atom({\n  key: \"enemyPosition\", // unique ID (with respect to other atoms/selectors)\n  default: [\n    { x: -20, y: 0, z: -60, text: \"about me\" },\n    { x: 5, y: 0, z: -60, text: \"experiences\" }\n  ] // default value (aka initial value)\n});\n\nexport const laserPositionState = atom({\n  key: \"laserPositions\", // unique ID (with respect to other atoms/selectors)\n  default: [] // default value (aka initial value)\n});\n\nexport const scoreState = atom({\n  key: \"score\", // unique ID (with respect to other atoms/selectors)\n  default: 0 // default value (aka initial value)\n});","export default __webpack_public_path__ + \"static/media/texturemap1024.83745453.png\";","export default __webpack_public_path__ + \"static/media/uluru-heightmap.4e40045d.png\";","import { useLoader, Canvas, useFrame, useThree } from '@react-three/fiber'\nimport { Suspense, useEffect, useRef, useMemo, useState } from 'react';\nimport { Environment,\n  OrbitControls,\n  useGLTF,\n  useFBX,\n  useTexture,\n  Loader,\n  PerspectiveCamera,\n  Billboard,\n  Plane,\n  Text\n} from \"@react-three/drei\";\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader'\nimport * as THREE from \"three\";\nimport { RecoilRoot, useRecoilState, useRecoilValue } from \"recoil\";\nimport {\n  tankPositionState,\n  enemyPositionState,\n  laserPositionState,\n  scoreState\n} from \"./gameState\";\nimport Pokemon from './static/Pokemon_Hollow_Normal.json';\nimport { vertexShader, fragmentShader } from \"./shaders\";\nimport texturemap1024 from './materials/texturemap1024.png'\nimport uluru from './materials/uluru-heightmap.png'\n\nconst LASER_RANGE = 100;\nconst LASER_Z_VELOCITY = 1;\nconst ENEMY_SPEED = 0.1;\nconst GROUND_HEIGHT = -50;\n\n/*\nAuto-generated by: https://github.com/pmndrs/gltfjsx\n*/\n\nfunction Model(props) {\n  const tank = useRef();\n  const [tankPosition, setTankPosition] = useRecoilState(tankPositionState);\n\n  useFrame(({ mouse }) => {\n    setTankPosition({\n      position: {\n        x: mouse.x,\n        y: mouse.y\n      },\n      rotation: {\n        z: -mouse.x * 0.5,\n        x: -mouse.x * 0.5,\n        y: -mouse.y * 0.2\n      }\n    });\n  });\n\n  useFrame(() => {\n    // tank.current.rotation.z = tankPosition.rotation.z;\n    // tank.current.rotation.y = tankPosition.rotation.x;\n    // tank.current.rotation.x = tankPosition.rotation.y;\n    // tank.current.position.y = tankPosition.position.y;\n    // tank.current.position.x = tankPosition.position.x;\n  });\n\n  // const { nodes, materials } = useGLTF('/personal-portfolio/tank.glb');\n  const fbx = useFBX('/personal-portfolio/tank.fbx');\n  // return <primitive object={fbx} dispose={false} />\n  // Material.003 gun center parts\n  // Material.002\n  useEffect(() => {\n    console.log(fbx);\n    fbx.traverse(child => {\n      if (child.isMesh) {\n        // console.log(child.geometry);\n        // console.log(child.material);\n        // console.log(typeof child.material)\n        // if (child.material.name === 'Material.002') {\n        //   child.material = new THREE.MeshBasicMaterial({ color: 'black'});\n        // }\n      }\n    })\n    fbx.children[1] = new THREE.PointLight(0x000000, 1, 100); // black\n    fbx.children[2] = new THREE.PointLight(0xffffff, 1, 100); // white\n    fbx.children[3] = new THREE.PointLight(0xf44336, 1, 100); // red\n    fbx.children[4] = new THREE.PointLight(0x8fce00, 1, 100); // green\n\n    // fbx.updateWorldMatrix(true);\n    console.log(fbx);\n  }, []);\n\n  return (\n    <group ref={tank} {...props} receiveShadow>\n      <primitive object={fbx} dispose={false} />\n      {/*\n     <group ref={tank}>\n       <mesh visible>\n         <boxBufferGeometry args={[1,1,1]} />\n         // <meshPhongMaterial color={'white'} />\n         <meshStandardMaterial\n           attach=\"material\"\n           color=\"white\"\n           roughness={1}\n           metalness={0}\n         />\n  </mesh> */}\n      {/* Main body */}\n      {/* <mesh\n        geometry={nodes.Cube.geometry}\n        material={nodes.Cube.material}\n        scale={[1.12173486, 0.85714293, 0.8402164]}\n      /> */}\n      {/* top shield for tires */}\n      {/* <mesh\n        geometry={nodes.Cube001.geometry}\n        material={nodes.Cube001.material}\n        position={[0, 0.05469192, 0]}\n        scale={0.80000001}\n      /> */}\n      {/* Top of the tank */}\n      {/* <group position={[0, 0.59999996, 0.1]}>\n        <mesh\n          geometry={nodes.Circle_1.geometry}\n          material={nodes.Circle_1.material}\n        />\n        <mesh\n          geometry={nodes.Circle_2.geometry}\n          material={materials[\"Material.002\"]}\n        />\n      </group> */}\n      {/* In between gun parts */}\n      {/* <mesh\n        geometry={nodes.Circle001.geometry}\n        material={nodes.Circle001.material}\n        position={[0, 1.06455553, 0.89632851]}\n        scale={0.20147002}\n      /> */}\n\n      {/* 1. outside tire rubber */}\n      {/* 2. Inner wheel i.e. rims */}\n      {/* <group position={[0, 0.05469192, 0]}>\n        <mesh\n          geometry={nodes.Cylinder_1.geometry}\n          material={materials[\"Material.004\"]}\n        />\n        <mesh\n          geometry={nodes.Cylinder_2.geometry}\n          material={nodes.Cylinder_2.material}\n        />\n      </group>\n      <group position={[0, 0.05469192, -1.5]}>\n        <mesh\n          geometry={nodes.Cylinder_1.geometry}\n          material={materials[\"Material.004\"]}\n        />\n        <mesh\n          geometry={nodes.Cylinder_2.geometry}\n          material={nodes.Cylinder_2.material}\n        />\n      </group>\n      <group position={[-2.70, 0.05469192, -1.5]}>\n        <mesh\n          geometry={nodes.Cylinder_1.geometry}\n          material={materials[\"Material.004\"]}\n        />\n        <mesh\n          geometry={nodes.Cylinder_2.geometry}\n          material={nodes.Cylinder_2.material}\n        />\n      </group>\n      <group position={[-2.70, 0.05469192, 0]}>\n        <mesh\n          geometry={nodes.Cylinder_1.geometry}\n          material={materials[\"Material.004\"]}\n        />\n        <mesh\n          geometry={nodes.Cylinder_2.geometry}\n          material={nodes.Cylinder_2.material}\n        />\n      </group> */}\n    </group>\n  );\n}\n\nuseGLTF.preload(\"/tank.gltf\");\n\n// const Terrain = () => {\n//   const terrainRef = useRef();\n\n//   useFrame(() => {\n//     terrainRef.current.position.z += 0.4;\n//   });\n\n//   return(\n//     <mesh\n//       visible\n//       position={[0,-100,0]}\n//       rotation={[-Math.PI / 2, 0, 0]}\n//       ref={terrainRef}\n//     >\n//       <planeBufferGeometry attach=\"geometry\" args={[5000, 5000, 128, 128]} />\n//       <meshStandardMaterial\n//         attach=\"material\"\n//         color=\"white\"\n//         roughness={1}\n//         metalness={0}\n//         wireframe\n//       />\n//     </mesh>\n//   );\n// };\n\nfunction Terrain(props) {\n  // const { gl } = useThree()\n  // const mat = useRef();\n\n  // Load the heightmap image \n  const heightMap = useTexture(uluru);\n  // Apply some properties to ensure it renders correctly\n  heightMap.encoding = THREE.sRGBEncoding;\n  heightMap.wrapS = THREE.RepeatWrapping;\n  heightMap.wrapT = THREE.RepeatWrapping;\n  heightMap.anisotropy = 16;\n\n  // Load the texture map\n  const textureMap = useTexture(texturemap1024);\n  // Apply some properties to ensure it renders correctly\n  textureMap.encoding = THREE.sRGBEncoding;\n  textureMap.wrapS = THREE.RepeatWrapping;\n  textureMap.wrapT = THREE.RepeatWrapping;\n  textureMap.anisotropy = 16;\n  textureMap.minFilter = THREE.LinearFilter;\n  const terrainRef = useRef();\n\n  useFrame(() => {\n    if (terrainRef.current.position.z > 350) {\n      terrainRef.current.position.z = -512;\n    } else {\n      terrainRef.current.position.z += props.GAME_SPEED;\n    }\n  });\n\n  // useEffect(() => {\n  //   if (mat.current) {\n  //     mat.current.map.minFilter = ;\n  //   }\n  // }, [mat]);\n\n  // this terrain is reversed on x y and z axis\n  return (\n    <mesh\n    position={[-300,-10,-512]}\n    rotation={[-Math.PI / 2,0,0]}\n    ref={terrainRef}\n    >\n      <planeBufferGeometry args={[1024, 1024, 256, 256]} />\n      <shaderMaterial\n      // ref={mat}\n        fog\n        uniforms={{\n          // Feed the heightmap\n          bumpTexture: { value: heightMap },\n          // Feed the scaling constant for the heightmap\n          bumpScale: { value: 40 },\n          // Feed the texture map\n          terrainTexture: { value: textureMap },\n          fog: true,\n          // lights: {\n          //   ambientLight\n          // }\n        }}\n        // map-\n        // Feed the shaders as strings\n        vertexShader={vertexShader}\n        fragmentShader={fragmentShader}\n        side={THREE.DoubleSide}\n      />\n    </mesh>\n  );\n}\n\nconst Target = (props) => {\n  return (\n    <group\n    position={props.position}\n    >\n      <mesh position={[props.position[0], props.position[1] + 15, props.position[2]]}>\n        <planeGeometry args={[30,20]} />\n        <meshBasicMaterial color={'black'} side={THREE.DoubleSide} />\n        <TargetText text={props.text} />\n      </mesh>\n      <mesh>\n        <cylinderBufferGeometry args={[1, 1, 15, 50, 1]} />\n        <meshBasicMaterial color={'black'} />\n      </mesh>\n    </group>\n  )\n}\n\n\n// billboard\n// const Target = (props) => {\n//   // const target = useRef();\n//   // const font = new THREE.FontLoader().parse(Pokemon);\n\n//   return (\n//     <group \n//       position={props.position}\n//     >\n//       <Billboard follow={true} lockX={false} lockY={false} lockZ={false} position={[0, 0, 0]}>\n//         {/* <Plane args={[3, 2]} material-color=\"green\" /> */}\n//         <Text fontSize={5} outlineWidth={'5%'} outlineColor=\"#000000\" outlineOpacity={1}>\n//           ABOUT ME\n//         </Text>\n//       </Billboard>\n//     </group>\n//   )\n// }\n\n\nconst TargetText = (props) => {\n  // const target = useRef();\n  const font = new THREE.FontLoader().parse(Pokemon);\n\n  const textOptions = {\n\t\tfont: font,\n\t\tsize: 2,\n\t\theight: .05,\n  };\n  return (\n    <group \n    // ref={target}\n    position={props.position}\n    >\n      <mesh>\n        <textGeometry args={[props.text, textOptions]} />\n          <meshPhongMaterial\n            emissive={'orange'}\n            roughness={1}\n            metalness={0}\n            wireframe\n            flatShading\n            vertexColors\n          />\n      </mesh>\n    </group>\n  )\n}\n\nconst Enemies = () => {\n  const enemies = useRecoilValue(enemyPositionState);\n\n  return (\n    enemies.map((enemy) => (\n      <Target position={[enemy.x, enemy.y, enemy.z]} text={enemy.text} key={Math.random()} />\n    ))\n  )\n}\n\n// Manages Drawing enemies that currently exist in state\n// function Enemies() {\n//   const enemies = useRecoilValue(enemyPositionState);\n//   return (\n//     <group>\n//       {enemies.map((enemy) => (\n//         <mesh position={[enemy.x, enemy.y, enemy.z]} key={`${enemy.x}`}>\n//           <sphereBufferGeometry attach=\"geometry\" args={[2, 8, 8]} />\n//           <meshStandardMaterial attach=\"material\" color=\"white\" wireframe />\n//         </mesh>\n//       ))}\n//     </group>\n//   );\n// }\n\nfunction Lasers() {\n  const lasers = useRecoilValue(laserPositionState);\n  return (\n    <group>\n      {lasers.map((laser) => (\n        <mesh position={[laser.x, laser.y, laser.z]} key={`${laser.id}`}>\n          <boxBufferGeometry attach=\"geometry\" args={[1, 1, 1]} />\n          <meshStandardMaterial attach=\"material\" emissive=\"white\" wireframe />\n        </mesh>\n      ))}\n    </group>\n  );\n}\n\n\nfunction LaserController() {\n  const shipPosition = useRecoilValue(tankPositionState);\n  const [lasers, setLasers] = useRecoilState(laserPositionState);\n  return (\n    <mesh\n      position={[0,0,-8]}\n      onClick={() =>\n        setLasers([\n          ...lasers,\n          {\n            id: Math.random(), // This needs to be unique.. Random isn't perfect but it works. Could use a uuid here.\n            x: 0,\n            y: 0,\n            z: 0,\n            velocity: [shipPosition.rotation.x * 6, shipPosition.rotation.y * 5]\n          }\n        ])\n      }\n    >\n      <planeBufferGeometry attach=\"geometry\" args={[100, 100]} />\n      <meshStandardMaterial\n        attach=\"material\"\n        color=\"orange\"\n        emissive=\"#ff0860\"\n        visible={false}\n      />\n    </mesh>\n  );\n}\n\nfunction distance(p1, p2) {\n  const a = p2.x - p1.x;\n  const b = p2.y - p1.y;\n  const c = p2.z - p1.z;\n\n  return Math.sqrt(a * a + b * b + c * c);\n}\n\nfunction GameTimer({ setAboutMeHit,setExperiencesHit }) {\n  const [enemies, setEnemies] = useRecoilState(enemyPositionState);\n  const [lasers, setLaserPositions] = useRecoilState(laserPositionState);\n  const [score, setScore] = useRecoilState(scoreState);\n\n  useFrame(({ mouse }) => {\n    // Calculate hits and remove lasers and enemies, increase score.\n\n    const hitEnemies = enemies\n      ? enemies.map(\n          (enemy) =>\n            lasers.filter(\n              () =>\n                lasers.filter((laser) => distance(laser, enemy) < 3).length > 0\n            ).length > 0\n        )\n      : [];\n    \n    if (hitEnemies.includes(true) && enemies.length > 0) {\n      setScore(score + 1);\n      if (hitEnemies && hitEnemies.length > 0) {\n        if (hitEnemies[0]) {\n          setAboutMeHit(true);\n        } else if (hitEnemies[1]) {\n          setExperiencesHit(true);\n        }\n      }\n    }\n\n    // Move all of the enemies. Remove enemies that have been destroyed, or passed the player.\n    // setEnemies(\n    //   enemies\n    //     .map((enemy) => ({ x: enemy.x, y: enemy.y, z: enemy.z + ENEMY_SPEED, text: \"new\"}))\n    //     .filter((enemy, idx) => !hitEnemies[idx] && enemy.z < 0)\n    // );\n    // Move the Lasers and remove lasers at end of range or that have hit the ground.\n    setLaserPositions(\n      lasers\n        .map((laser) => ({\n          id: laser.id,\n          x: laser.x + laser.velocity[0],\n          y: laser.y + laser.velocity[1],\n          z: laser.z - LASER_Z_VELOCITY,\n          velocity: laser.velocity\n        }))\n        .filter((laser) => laser.z > -LASER_RANGE && laser.y > GROUND_HEIGHT)\n    );\n  });\n  return null;\n}\n\nconst Modal = ({ show, setAboutMeHit, text }) => {\n  const showHideClassName = show ? \"modal display-block\" : \"modal display-none\";\n\n  const dosomething = (e) => {\n    e.preventDefault();\n    setAboutMeHit(false);\n  }\n\n  return (\n    <div className={showHideClassName}>\n      <section className=\"modal-main\">\n        <div>{text}</div>\n        <button type=\"button\" onClick={e => dosomething(e)}>\n          Close\n        </button>\n      </section>\n    </div>\n  );\n};\n\nconst App = () => {\n  const ref = useRef();\n  const [speed, setSpeed] = useState(0.2);\n  const [aboutMeHit, setAboutMeHit] = useState(false);\n  const [experiencesHit, setExperiencesHit] = useState(false);\n\n  // const showModal = () => {\n  //   this.setState({ show: true });\n  // };\n\n  // const hideModal = () => {\n  //   setAboutMeHit(false);\n  // };\n\n  useEffect(() => {\n    if(!aboutMeHit) {\n      setSpeed(0.2);\n    } else {\n      setSpeed(0.05)\n    }\n  }, [aboutMeHit])\n  return (\n    <>\n    <Canvas\n      style={{ background: \"#cdf9ff\" }}\n      // camera={{ \n        // fov: 150,\n        // aspect: window.innerWidth / window.innerHeight,\n        // near: 0.01,\n        // far: 10000,\n      //   // position: [0, 0, 1]\n      // }}\n      camera={{ fov: 75, near: 0.1, far: 1000, position: [0, 2, 5] }}\n      // gl={{ antialias: false }} pixelRatio={4}\n      dpr={Math.max(window.devicePixelRatio, 2)}\n      ref={ref}\n    >\n\n    <RecoilRoot>\n    {/* <directionalLight intensity={1} /> */}\n          {/* <ambientLight intensity={1} /> */}\n      <Terrain GAME_SPEED={speed}/>\n      <Suspense fallback={null}>\n        <Model\n          scale={[.008,.008,.008]}\n          position={[0,-3,0]}\n          rotation={[0,Math.PI,0]}\n        />\n      </Suspense>\n      {/* <ambientLight /> */}\n      {/* <Target position={[-20, 10, -20]} text={\"about me\"}/>\n      <Target position={[5, 10, -20]} text={\"experiences\"}/> */}\n      <Enemies />\n      <Lasers />\n      <LaserController />\n      <GameTimer \n        setAboutMeHit={setAboutMeHit} \n        setExperiencesHit={setExperiencesHit}      \n      />\n        {/* <OrbitControls /> */}\n    </RecoilRoot>\n  </Canvas>\n\n    {aboutMeHit &&\n      <Modal show={aboutMeHit} setAboutMeHit={setAboutMeHit} text={\"Modal\"}>\n      </Modal>\n      }\n    </>\n  )\n}\n\nexport default App;","export const vertexShader = `\n// Uniforms are data that are shared between shaders\n// The contain data that are uniform across the entire frame.\n// The heightmap and scaling constant for each point are uniforms in this respect.\n\n// A uniform to contain the heightmap image\nuniform sampler2D bumpTexture;\n// A uniform to contain the scaling constant\nuniform float bumpScale;\n\n// Varyings are variables whose values are decided in the vertext shader\n// But whose values are then needed in the fragment shader\n\n// A variable to store the height of the point\nvarying float vAmount;\n// The UV mapping coordinates of a vertex\nvarying vec2 vUV;\n\nvoid main()\n{\n    // The \"coordinates\" in UV mapping representation\n    vUV = uv;\n\n    // The heightmap data at those coordinates\n    vec4 bumpData = texture2D(bumpTexture, uv);\n\n    // height map is grayscale, so it doesn't matter if you use r, g, or b.\n    vAmount = bumpData.r;\n\n    // move the position along the normal\n    vec3 newPosition = position + normal * bumpScale * vAmount;\n\n    // Compute the position of the vertex using a standard formula\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n`;\n\nexport const fragmentShader = `\n// A uniform fot the terrain texture image\nuniform sampler2D terrainTexture;\n\n// Get the varyings from the vertex shader\nvarying vec2 vUV;\n// vAmount isn't really used, but could be if necessary\nvarying float vAmount;\n\nvoid main()\n{\n    // Get the color of the fragment from the texture map\n    // at that coordinate in the UV mapping\n    gl_FragColor = texture2D(terrainTexture, vUV);\n}\n`;\n","import React, { Suspense } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css'\nimport App from './App';\n\nReactDOM.render(\n  <Suspense fallback={null}>\n    <App />,\n  </Suspense>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}